---
alwaysApply: true
---
You are an expert in Python, Django, and scalable web application development.

Key Principles

- Write clear, technical responses with precise Django examples.
- Use Django's built-in features and tools wherever possible to leverage its full capabilities.
- Prioritize readability and maintainability; follow Django's coding style guide (PEP 8 compliance).
- Use descriptive variable and function names; adhere to naming conventions (e.g., lowercase with underscores for functions and variables).
- Structure your project in a modular way using Django apps to promote reusability and separation of concerns.

Django/Python

- Use Django‚Äôs class-based views (CBVs) for more complex views; prefer function-based views (FBVs) for simpler logic.
- Leverage Django‚Äôs ORM for database interactions; avoid raw SQL queries unless necessary for performance.
- Use Django‚Äôs built-in user model and authentication framework for user management.
- Utilize Django's form and model form classes for form handling and validation.
- Follow the MVT (Model-View-Template) pattern strictly for clear separation of concerns.
- Use middleware judiciously to handle cross-cutting concerns like authentication, logging, and caching.

Error Handling and Validation

- Implement error handling at the view level and use Django's built-in error handling mechanisms.
- Use Django's validation framework to validate form and model data.
- Prefer try-except blocks for handling exceptions in business logic and views.
- Customize error pages (e.g., 404, 500) to improve user experience and provide helpful information.
- Use Django signals to decouple error handling and logging from core business logic.

Dependencies

- Django
- Django REST Framework (for API development)
- Celery (for background tasks)
- Redis (for caching and task queues)
- PostgreSQL or MySQL (preferred databases for production)

Django-Specific Guidelines

- Use Django templates for rendering HTML and DRF serializers for JSON responses.
- Keep business logic in models and forms; keep views light and focused on request handling.
- Use Django's URL dispatcher (urls.py) to define clear and RESTful URL patterns.
- Apply Django's security best practices (e.g., CSRF protection, SQL injection protection, XSS prevention).
- Use Django‚Äôs built-in tools for testing (unittest and pytest-django) to ensure code quality and reliability.
- Leverage Django‚Äôs caching framework to optimize performance for frequently accessed data.
- Use Django‚Äôs middleware for common tasks such as authentication, logging, and security.

Performance Optimization

- Optimize query performance using Django ORM's select_related and prefetch_related for related object fetching.
- Use Django‚Äôs cache framework with backend support (e.g., Redis or Memcached) to reduce database load.
- Implement database indexing and query optimization techniques for better performance.
- Use asynchronous views and background tasks (via Celery) for I/O-bound or long-running operations.
- Optimize static file handling with Django‚Äôs static file management system (e.g., WhiteNoise or CDN integration).

Key Conventions

1. Follow Django's "Convention Over Configuration" principle for reducing boilerplate code.
2. Prioritize security and performance optimization in every stage of development.
3. Maintain a clear and logical project structure to enhance readability and maintainability.

Refer to Django documentation for best practices in views, models, forms, and security considerations.


# About Game Player Nick Finder

## Project Overview
**Game Player Nick Finder** is a Django-based web application designed to help users reconnect with their old gaming friends. The platform allows users to search for friends by their gaming nicknames, create profiles for their gaming characters, and communicate through a messaging system.

## Key Features
- **User Registration & Authentication**: Custom user model with extended fields (birthday, social media links, gender).
- **Character Profiles**: Users can create multiple gaming characters with nicknames, avatars, and descriptions.
- **Game Management**: Database of games with categories, descriptions, and icons.
- **Search Functionality**: Search for friends by nickname, game, and time period.
- **Messaging System**: Users can send messages to each other.
- **Email Notifications**: Notifications for new messages and friend requests.
- **Social Integration**: Google authentication via django-allauth.

## Technical Stack
- **Front-end**: Bootstrap 5, Django Templates
- **Back-end**: Django, Django REST Framework
- **Database**: SQLite (default), with migrations set up
- **Authentication**: django-allauth, custom user model
- **Forms**: django-crispy-forms with Bootstrap 5 integration
- **Deployment**: Gunicorn, PM2, Nginx
- **CI/CD**: GitHub Actions for Django CI

## Current State
- Core functionality implemented
- Basic templates and styling in place
- Database models and migrations set up
- Authentication system working
- Ready for feature development and testing

## Next Steps
1. Implement advanced search functionality
2. Enhance messaging system
3. Add more game data
4. Improve UI/UX
5. Set up proper testing
6. Implement API endpoints for mobile integration

## Testing Requirements (CRITICAL)

### Playwright E2E Testing
- **MANDATORY**: Every feature must have Playwright E2E tests
- **MANDATORY**: Every component must be tested with Playwright
- **MANDATORY**: Every page/route must have Playwright tests
- **MANDATORY**: All user flows must be covered by Playwright tests

### Test-Driven Development (TDD)
1. **ALWAYS** write Playwright test first (red phase)
2. Implement feature (green phase)
3. Refactor (refactor phase)
4. **NEVER** commit code without corresponding Playwright tests

### Test Coverage Requirements
- Minimum 80% E2E test coverage for all user flows
- All critical paths must have Playwright tests
- All API endpoints must have Playwright API tests
- All UI components must have Playwright component tests

### Running Tests

**‚ö° SZYBKIE TESTOWANIE (Domy≈õlne - dla szybkich iteracji)**:
```bash
# Run all Playwright tests (FAST - only Chromium, ~2-3 min)
pnpm test:e2e

# Run specific test file (very fast, ~5-10 sec)
pnpm test:e2e tests/e2e/feature-name.spec.ts
```

**üåê WSZYSTKIE PRZEGLƒÑDARKI (Przed commitem/merge do main)**:
```bash
# Run all browsers (Chromium, Firefox, WebKit - ~7-9 min)
pnpm test:e2e:all

# Alias (wolne testy)
pnpm test:e2e:slow

# Run specific browser
pnpm test:e2e:chromium
pnpm test:e2e:firefox
pnpm test:e2e:webkit
```

**üîß DEBUGGING**:
```bash
# Run in UI mode (interactive)
pnpm test:e2e:ui

# Run in headed mode (see browser)
pnpm test:e2e:headed

# Debug tests
pnpm test:e2e:debug
```

**üìã Dokumentacja**: Zobacz `docs/testing/FAST_TESTING_GUIDE.md` - pe≈Çny przewodnik szybkiego testowania

**‚ö†Ô∏è WA≈ªNE**:
- **Domy≈õlnie** (`pnpm test:e2e`) testuje tylko **Chromium** (najszybsze, ~2-3 min)
- U≈ºywa `line` reportera (prostsze komunikaty)
- Idealne do szybkich iteracji podczas naprawiania test√≥w
- **U≈ºywaj zawsze podczas codziennej pracy na komputerze**
- **Przed commitem/merge do main** u≈ºyj `pnpm test:e2e:all` (wszystkie przeglƒÖdarki, ~7-9 min)
- **VSCode Tasks**: `Run E2E Tests` (szybkie) i `Run E2E Tests (All Browsers)` (wolne)

### E2E Test Results Files (CRITICAL - Gitignored)

**MANDATORY**: Pliki wynik√≥w test√≥w E2E sƒÖ **GITIGNOROWANE** i **NIE POWINNY** byƒá komitowane do repozytorium.

**Nazewnictwo plik√≥w wynik√≥w test√≥w**:
- Format: `test-results-YYYY-MM-DD_HH-mm-ss.txt` (data-godzina rozpoczƒôcia test√≥w)
- Przyk≈Çad: `test-results-2025-12-29_19-26-06.txt`
- Format daty: `YYYY-MM-DD_HH-mm-ss` (rok-miesiƒÖc-dzie≈Ñ_godzina-minuta-sekunda)
- U≈ºyj: `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"` (PowerShell) lub `date +"%Y-%m-%d_%H-%M-%S"` (Bash) do wygenerowania timestampu

**Gitignore**:
- Wszystkie pliki `test-results-*.txt` sƒÖ automatycznie ignorowane przez `.gitignore`
- **NIGDY** nie komituj plik√≥w wynik√≥w test√≥w
- Pliki wynik√≥w test√≥w sƒÖ artefaktami lokalnymi i nie powinny byƒá w repozytorium

**Przyk≈Çad u≈ºycia**:
```powershell
# PowerShell
$timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
pnpm test:e2e > "test-results-$timestamp.txt" 2>&1
```

```bash
# Bash
timestamp=$(date +"%Y-%m-%d_%H-%M-%S")
pnpm test:e2e > "test-results-$timestamp.txt" 2>&1
```

### Test Structure
```
tests/
‚îú‚îÄ‚îÄ e2e/                    # Playwright E2E tests
‚îÇ   ‚îú‚îÄ‚îÄ messaging/          # Messaging feature tests
‚îÇ   ‚îú‚îÄ‚îÄ friends/            # Friend system tests
‚îÇ   ‚îú‚îÄ‚îÄ profile/            # Profile tests
‚îÇ   ‚îî‚îÄ‚îÄ characters/        # Character tests
‚îú‚îÄ‚îÄ unit/                   # Unit tests (Vitest)
‚îî‚îÄ‚îÄ api/                    # API tests (Playwright)
```

### Test Data Requirements (CRITICAL)
- **MANDATORY**: All E2E tests require seeded test data to run properly
- **MANDATORY**: Database must be seeded with fixtures before running E2E tests
- **MANDATORY**: Test fixtures include users, characters, messages, friend requests, and friendships
- **ALWAYS**: Load fixtures before running E2E tests using: `pipenv run python manage.py loaddata app/fixtures/categories_fixtures.json app/fixtures/games_fixtures.json app/fixtures/users_and_characters.json`
- **ALWAYS**: Use script: `pnpm load:fixtures` or `.\load_fixtures.ps1` (Windows) / `./load_fixtures.sh` (Unix)
- Test users available:
  - `testuser` / `testpass123` - Main test user with multiple characters
  - `otheruser` / `pass` - Secondary test user
  - `privateuser` / `testpass123` - User with private profile

### Before Every Commit
- [ ] All Playwright tests pass locally (`pnpm test:e2e` - fast, Chromium only)
- [ ] Before pushing to dev: Run `pnpm test:e2e:all` (all browsers) if making significant changes
- [ ] New features have Playwright tests
- [ ] Database fixtures are up to date (`pnpm load:fixtures`)
- [ ] No console errors
- [ ] ESLint passes
- [ ] TypeScript compiles without errors

**‚ö° Szybkie iteracje**: U≈ºywaj `pnpm test:e2e` (tylko Chromium) podczas naprawiania test√≥w
**üåê Przed commitem/merge**: U≈ºywaj `pnpm test:e2e:all` (wszystkie przeglƒÖdarki) przed push do dev lub merge do main

### ‚ö†Ô∏è CRITICAL: Login Issues (P0 - Must Fix First)

**Problem**: Login functionality in E2E tests is failing - ~12+ tests blocked by login helper failures.

**Status**: ‚ö†Ô∏è **WYMAGA NAPRAWY** - Passing rate: ~30% (34-48 passed / 104-118 failed)

**Main Issues**:
1. **Login Helper Failures** (P0 - Critical)
   - `login()` helper function fails in `beforeEach` hooks
   - Error: "Login failed - still on login page after redirect wait"
   - Affected files: `logout.spec.ts`, `password-change.spec.ts`, `login.spec.ts`
   - **Root Cause**: `CustomLoginView` has `redirect_authenticated_user = True`, causing race conditions

2. **Authentication Verification Failures** (P0 - Critical)
   - `isAuthenticated()` returns `false` after successful login
   - Timing issues with user menu visibility

**üìã Dokumentacja do przeczytania przed naprawƒÖ**:
- **[docs/testing/LOGIN_FAILURE_ANALYSIS.md](../docs/testing/LOGIN_FAILURE_ANALYSIS.md)** - Szczeg√≥≈Çowa analiza problem√≥w z logowaniem
- **[docs/testing/E2E_REMAINING_ISSUES.md](../docs/testing/E2E_REMAINING_ISSUES.md)** - Lista pozosta≈Çych problem√≥w (P0/P1/P2/P3)
- **[docs/testing/FIX_ATTEMPTS_AND_RESULTS.md](../docs/testing/FIX_ATTEMPTS_AND_RESULTS.md)** - Wszystkie pr√≥by naprawy i ich wyniki
- **[docs/testing/LOGIN_HELPER_FIX_STATUS.md](../docs/testing/LOGIN_HELPER_FIX_STATUS.md)** - Status naprawy funkcji `login()` helper
- **[docs/architecture/restore-allauth/RESTORE_ALLAUTH_AGENTS_WORKFLOW.md](../docs/architecture/restore-allauth/RESTORE_ALLAUTH_AGENTS_WORKFLOW.md)** - Plan przywracania allauth (je≈õli potrzebne)

**üîß Plan naprawy**:
1. **Przeczytaj dokumentacjƒô** - szczeg√≥lnie `LOGIN_FAILURE_ANALYSIS.md` i `E2E_REMAINING_ISSUES.md`
2. **Zidentyfikuj root cause** - sprawd≈∫ czy problem jest w:
   - `CustomLoginView` configuration (`app/views.py`)
   - `login()` helper function (`tests/helpers/auth-helpers.ts`)
   - Test fixtures/users setup (`app/fixtures/users_and_characters.json`)
   - Django allauth configuration
3. **Napraw login helper** - zobacz `docs/testing/LOGIN_HELPER_FIX_STATUS.md` dla pr√≥b naprawy
4. **Przetestuj lokalnie** - u≈ºyj `pnpm test:e2e` (szybkie) do iteracji
5. **Przed commitem** - u≈ºyj `pnpm test:e2e:all` (wszystkie przeglƒÖdarki)

**üìç Lokalizacja kodu**:
- Login helper: `tests/helpers/auth-helpers.ts`
- Login view: `app/views.py` (szukaj `CustomLoginView`)
- Login template: `app/templates/account/login.html`
- Test users: `app/fixtures/users_and_characters.json`

## Database Seeding and Superuser Management (CRITICAL)

### Seeding Scripts Overview
The project uses automated seeding scripts that load fixtures AND automatically create superuser accounts. All seeding scripts are integrated with the superuser creation system.

### Available Seeding Scripts

#### Cross-Platform Scripts
- **`pnpm load:fixtures`** - Cross-platform script (calls appropriate platform-specific script)
- **`scripts/load-fixtures.js`** - Node.js wrapper that detects OS and calls correct script

#### Windows (PowerShell)
- **`load_fixtures.ps1`** - Main seeding script for Windows
  - Loads: categories, games, users and characters fixtures
  - **AUTOMATICALLY** creates superuser after loading fixtures (if `.dot/sudo_user` exists)

#### Unix/Linux/MacOS (Bash)
- **`load_fixtures.sh`** - Main seeding script for Unix systems
  - Loads: categories, games, users and characters fixtures
  - **AUTOMATICALLY** creates superuser after loading fixtures (if `.dot/sudo_user` exists)

#### Additional Seeding Scripts
- **`scripts/first_time_seed.sh`** - First-time deployment seeding (production)
  - Checks if database is empty before seeding
  - **AUTOMATICALLY** creates superuser after seeding (if `.dot/sudo_user` exists)
- **`scripts/reset_db.sh --create-superuser`** - Database reset with superuser creation
  - Uses `create_superuser.sh --auto` when available

### Superuser Creation System

#### How It Works
1. **First Time Setup**: User runs `create_superuser.ps1` (Windows) or `create_superuser.sh` (Unix)
   - Script prompts for: username, email, password
   - Saves credentials to `.dot/sudo_user` (in `.gitignore`, never committed)
   - Creates superuser in database

2. **Automatic Mode**: All seeding scripts automatically call superuser creation in `--auto` mode
   - Reads credentials from `.dot/sudo_user`
   - Creates superuser if it doesn't exist
   - Skips if user already exists (returns success)
   - If `.dot/sudo_user` doesn't exist, shows helpful message

#### Superuser Scripts
- **`create_superuser.ps1`** (Windows) - Interactive or auto mode
  - Usage: `.\create_superuser.ps1` (interactive) or `.\create_superuser.ps1 --auto` (automatic)
- **`create_superuser.sh`** (Unix) - Interactive or auto mode
  - Usage: `./create_superuser.sh` (interactive) or `./create_superuser.sh --auto` (automatic)
- **`scripts/create_superuser.py`** - Python script used by both shell scripts
  - Creates superuser via Django ORM
  - Returns success if user already exists (idempotent)

#### Credentials Storage
- **Location**: `.dot/sudo_user` (in project root)
- **Format**:
  ```
  username: your_username
  email: your@email.com
  password: your_password
  ```
- **Security**: File is in `.gitignore`, never committed to repository
- **Purpose**: Allows automatic superuser creation during seeding

### Integration with Seeding Scripts

**CRITICAL**: All seeding scripts automatically create superuser after loading fixtures:
1. `load_fixtures.ps1` / `load_fixtures.sh` - After loading all fixtures
2. `scripts/first_time_seed.sh` - After first-time seeding
3. `scripts/reset_db.sh --create-superuser` - After database reset

**Workflow**:
1. User runs seeding script (e.g., `.\load_fixtures.ps1`)
2. Script loads all fixtures (categories, games, users, characters)
3. Script automatically calls `create_superuser.ps1 --auto` (or `.sh --auto`)
4. If `.dot/sudo_user` exists, superuser is created/verified
5. If `.dot/sudo_user` doesn't exist, script shows message to run `create_superuser.ps1` first

### Important Rules for Agents

- **ALWAYS**: When modifying seeding scripts, ensure superuser creation is called after fixtures are loaded
- **ALWAYS**: Use `--auto` flag when calling superuser scripts from other scripts
- **ALWAYS**: Check if `.dot/sudo_user` exists before attempting automatic creation
- **NEVER**: Commit `.dot/sudo_user` file (it's in `.gitignore`)
- **NEVER**: Hardcode superuser credentials in scripts
- **ALWAYS**: Make superuser creation idempotent (safe to run multiple times)
- **ALWAYS**: Return success if user already exists (don't treat as error)

### Example Usage

```powershell
# First time setup (Windows)
.\create_superuser.ps1  # Prompts for credentials, saves to .dot/sudo_user

# Load fixtures (automatically creates superuser)
.\load_fixtures.ps1  # Loads fixtures + creates superuser automatically

# Or use cross-platform script
pnpm load:fixtures  # Works on both Windows and Unix
```

```bash
# First time setup (Unix)
./create_superuser.sh  # Prompts for credentials, saves to .dot/sudo_user

# Load fixtures (automatically creates superuser)
./load_fixtures.sh  # Loads fixtures + creates superuser automatically
```

## Technology Stack (Future Migration)

### Target Stack (Cloudflare Migration)
- **Frontend**: Next.js 14+ (App Router) + TypeScript + Joy UI + Tailwind CSS
- **Backend**: Cloudflare Workers (TypeScript)
- **Database**: Cloudflare D1 (SQLite)
- **Storage**: Cloudflare R2 (media files)
- **Auth**: Cloudflare AUG
- **Testing**: Playwright (E2E) + Vitest (Unit) + React Testing Library

### Current Stack (Django)
- **Frontend**: Django Templates + Bootstrap 5
- **Backend**: Django 5.1.4 + DRF
- **Database**: SQLite (dev) / PostgreSQL (prod)
- **Testing**: Django TestCase + Playwright (E2E)

## Important Notes
- The project uses UUIDs for all models
- Bootstrap 5 is used for styling (current)
- Joy UI will be used after migration to Next.js
- django-crispy-forms handles form rendering (current)
- Email notifications are implemented but need proper SMTP configuration
- The project is ready for deployment with PM2 and Nginx
- **Playwright tests are mandatory for all features**

## Project Status Documentation

**CRITICAL**: Always check project status before starting work:

- **[Project Status Summary](../docs/PROJECT_STATUS_SUMMARY.md)** - Comprehensive status overview
  - What works (implemented features)
  - What needs work (pending tasks)
  - E2E test coverage
  - Priority tasks with story points
  - Next steps and timeline

- **[Status Report](../docs/STATUS_REPORT.md)** - Current implementation status
  - ‚úÖ Completed features (Backend + UI)
  - ‚ö†Ô∏è Features requiring further work
  - üìã Priority tasks to complete
  - Test coverage status

- **[Implementation Guide](../docs/architecture/implementation-guide.md)** - Step-by-step guide for mid-level developers
  - Prerequisites and setup
  - Implementation workflow (TDD)
  - Priority tasks with detailed steps
  - Code examples and patterns
  - Testing checklist
  - Best practices

## How to Use Documentation

### Before Starting Work

**ALWAYS** follow this workflow:

1. **Check Project Status**:
   - Read [Project Status Summary](../docs/PROJECT_STATUS_SUMMARY.md) to see if task is already done
   - Check [Status Report](../docs/STATUS_REPORT.md) for current implementation status
   - Verify task is not already completed

2. **Understand Requirements**:
   - Read [Implementation Guide](../docs/architecture/implementation-guide.md) for step-by-step instructions
   - Review [Detailed Tasks](../docs/scrum/detailed-tasks.md) for code examples
   - Check [005-pending-tasks-implementation.md](../docs/scrum/005-pending-tasks-implementation.md) for specific task details

3. **Setup Environment**:
   - Load fixtures: `pnpm load:fixtures` or `.\load_fixtures.ps1` (Windows) / `./load_fixtures.sh` (Unix)
   - Run migrations: `python manage.py migrate`
   - Ensure test environment is ready

### During Implementation

1. **Follow TDD**:
   - Write Playwright test first (red phase)
   - Implement feature (green phase)
   - Refactor (refactor phase)
   - **NEVER** commit without tests

2. **Use Existing Patterns**:
   - Follow code patterns in `app/models.py`, `app/views.py`, `app/forms.py`
   - Use existing template structure from `app/templates/`
   - Follow API patterns from `app/api_views.py`

3. **Reference Documentation**:
   - Check [Implementation Guide](../docs/architecture/implementation-guide.md) for code examples
   - Review [Detailed Tasks](../docs/scrum/detailed-tasks.md) for similar implementations
   - Use [005-pending-tasks-implementation.md](../docs/scrum/005-pending-tasks-implementation.md) for specific task steps

### After Completing Task

**MANDATORY**: Update status documentation after completing any task:

1. **Update Status Report** (`docs/STATUS_REPORT.md`):
   - Change task status from `‚ùå` to `‚úÖ` or `‚ö†Ô∏è` to `‚úÖ`
   - Update "Co zosta≈Ço zrobione" section
   - Remove from "Co nie zosta≈Ço zrobione" if fully complete
   - Update test status if tests were verified

2. **Update Project Status Summary** (`docs/PROJECT_STATUS_SUMMARY.md`):
   - Update statistics (Epiki, Testy E2E, etc.)
   - Move completed task from "Co wymaga pracy" to "Co dzia≈Ça"
   - Update "Pokrycie Testami E2E" section if tests were added/verified
   - Update "Nastƒôpne kroki" section

3. **Update Detailed Tasks** (`docs/scrum/detailed-tasks.md`):
   - Mark acceptance criteria as complete: `- [x]` instead of `- [ ]`
   - Update task status in header if present
   - Add completion date if documented

4. **Update Implementation Guide** (`docs/architecture/implementation-guide.md`):
   - Mark task as complete in checklist
   - Update "Next Steps" section
   - Add notes if implementation differed from guide

5. **Commit Changes**:
   - Include status documentation updates in PR
   - Commit message should mention: "Update status documentation for [task name]"
   - Example: `git commit -m "feat: implement conversation management UI + update status docs"`

### Status Update Checklist

After completing any task, verify:

- [ ] Status Report updated (`docs/STATUS_REPORT.md`)
- [ ] Project Status Summary updated (`docs/PROJECT_STATUS_SUMMARY.md`)
- [ ] Detailed Tasks acceptance criteria marked complete
- [ ] Implementation Guide checklist updated (if applicable)
- [ ] All Playwright tests pass
- [ ] Manual testing completed
- [ ] Code reviewed
- [ ] Documentation changes included in PR

### Status Symbols Reference

When updating status documents, use these symbols:

- `‚úÖ` - Completed / Working
- `‚ö†Ô∏è` - In Progress / Needs Verification
- `‚ùå` - Not Started / Missing
- `üìç` - Location / Reference
- `üìã` - Documentation / Checklist
- `üéØ` - Priority / Target

### Example Status Update

**Before** (in STATUS_REPORT.md):
```markdown
1. **Weryfikacja test√≥w Playwright** ‚ö†Ô∏è
   - Status: Testy napisane, wymagajƒÖ uruchomienia
```

**After** (after completing):
```markdown
1. **Weryfikacja test√≥w Playwright** ‚úÖ
   - Status: Testy zweryfikowane, wszystkie przechodzƒÖ
   - Data uko≈Ñczenia: 2024-12-19
```

**Before starting any task**:
1. Check [Project Status Summary](../docs/PROJECT_STATUS_SUMMARY.md) to see if it's already done
2. Check [Status Report](../docs/STATUS_REPORT.md) for current status
3. Read [Implementation Guide](../docs/architecture/implementation-guide.md) for step-by-step instructions
4. Review [Detailed Tasks](../docs/scrum/detailed-tasks.md) for implementation steps
5. Always write Playwright tests first (TDD)

## Session Management

### Session Recording Procedure

**CRITICAL**: Always record and update session information for tracking work progress.

#### When to Create a New Session

1. **New Chat**: When opening a completely new chat conversation
2. **Topic Change**: When completely changing the topic/scope of work
3. **Time Boundary**: Sessions start from 5:00 AM (4:00-6:00 AM window)

#### Session Structure

- **Location**: `.cursor/sessions/`
- **Naming Format**: `YYYY-MM-DD_HH-MM.md` (start time of session)
- **Initial State**: 
  - Only contains start date/time (no title initially)
  - Title is added/updated later when we understand what the session is about
- **Updates**: Session file should be updated:
  - After finishing conversation with user (before starting work)
  - After completing work tasks

#### Session File Format

```markdown
# Session: YYYY-MM-DD HH:MM

**Started**: YYYY-MM-DD HH:MM
**Title**: (initially empty, add/update later when scope is clear)

## Work Done
- [ ] Task 1
- [ ] Task 2

## Status
- Completed tasks
- Pending tasks
- Notes
```

#### Project Status Summary Updates

**CRITICAL**: After completing work, update `docs/PROJECT_STATUS_SUMMARY.md` using GitHub Flavored Markdown task checkboxes:

- `- [x]` - Task completed
- `- [ ]` - Task not completed
- Use checkboxes to track what was done and what wasn't

Update procedure:
1. Mark completed tasks with `- [x]`
2. Mark incomplete tasks with `- [ ]`
3. Update status symbols (‚úÖ, ‚ö†Ô∏è, ‚ùå)
4. Update "Co zosta≈Ço zrobione" / "Co wymaga pracy" sections

## Git Workflow Rules

**CRITICAL**: This project uses a **protected main branch** strategy. ALWAYS work on `dev` branch, NEVER commit directly to `main`.

### Default Branch for Development
- **Development branch**: `dev`
- **Production branch**: `main` (protected)
- **Feature branches**: `feature/feature-name` (created from `dev`)
- **Hotfix branches**: `hotfix/bug-name` (created from `main`, emergency only)

### Daily Development Workflow

**MANDATORY**: Follow this workflow for ALL development work:

```bash
# 1. Start from dev branch
git checkout dev
git pull origin dev

# 2. Make your changes
# Edit files...

# 3. Commit to dev
git add .
git commit -m "feat: description of changes"

# 4. Push to dev
git push origin dev

# 5. GitHub Actions runs automatically
#    - E2E tests run (~15 minutes)
#    - Django CI tests run (~5 minutes)
#    - Wait for tests to complete

# 6. If tests PASS:
#    - Go to GitHub
#    - Create PR: dev ‚Üí main
#    - Wait for tests to run on PR
#    - Merge PR to main

# 7. If tests FAIL:
#    - Fix the issues
#    - Commit to dev again
#    - Push to dev
#    - Repeat until tests pass
```

### Feature Branch Workflow (Larger Features)

For features requiring multiple commits:

```bash
# 1. Create feature branch from dev
git checkout dev
git pull origin dev
git checkout -b feature/feature-name

# 2. Work on feature (multiple commits allowed)
git add .
git commit -m "feat: implement part 1"
# ... more commits ...

# 3. Push feature branch
git push -u origin feature/feature-name

# 4. Create PR: feature/feature-name ‚Üí dev
#    - Tests run automatically
#    - Merge to dev after tests pass

# 5. When ready for production:
#    - Create PR: dev ‚Üí main
#    - Merge after tests pass
```

### Critical Git Rules

**NEVER**:
- ‚ùå **NEVER** commit directly to `main` branch
- ‚ùå **NEVER** push to `main` branch
- ‚ùå **NEVER** bypass branch protection rules
- ‚ùå **NEVER** skip tests before merging to `main`
- ‚ùå **NEVER** force push to `main` or `dev`
- ‚ùå **NEVER** use `git push --force` on shared branches

**ALWAYS**:
- ‚úÖ **ALWAYS** work on `dev` branch (or feature branches created from `dev`)
- ‚úÖ **ALWAYS** push to `dev` first
- ‚úÖ **ALWAYS** wait for GitHub Actions tests to pass
- ‚úÖ **ALWAYS** use Pull Requests for `dev ‚Üí main`
- ‚úÖ **ALWAYS** update documentation in commits
- ‚úÖ **ALWAYS** run tests locally before pushing: `pnpm test:e2e`

### Emergency Hotfix Workflow

**ONLY** for critical production bugs requiring immediate fix:

```bash
# 1. Create hotfix branch from main
git checkout main
git pull origin main
git checkout -b hotfix/critical-bug-name

# 2. Fix the bug
# Edit files...

# 3. Commit and push
git add .
git commit -m "hotfix: fix critical production bug"
git push -u origin hotfix/critical-bug-name

# 4. Create PR: hotfix/critical-bug-name ‚Üí main
#    - Tests MUST pass even for hotfixes
#    - NO bypassing tests allowed

# 5. After merge and deploy:
#    - Sync dev with main
git checkout dev
git merge main
git push origin dev
```

### GitHub Actions Integration

**Automatic Testing Triggers**:
- Push to `dev` ‚Üí Tests run automatically
- Push to `main` ‚Üí Tests run automatically
- Pull Request to `dev` or `main` ‚Üí Tests run automatically

**Test Workflows**:
- `e2e-tests.yml` - Playwright E2E tests on 3 browsers (~15 min)
- `django-ci.yml` - Django unit tests + linting (~5 min)

**Test Results**:
- ‚úÖ Green check mark = All tests passed, safe to merge
- ‚ùå Red X = Tests failed, must fix before merging
- ‚è≥ Yellow dot = Tests still running, wait for completion

### Render Deployment

**Auto-Deploy Configuration**:
- Render watches **`main` branch ONLY**
- When `main` is updated (via PR merge), Render deploys automatically
- `dev` branch changes **DO NOT** trigger deployment
- Deployment takes ~5-10 minutes
- Render automatically rolls back if deploy fails

**Complete Workflow**:
```
Developer ‚Üí Commit to dev ‚Üí Push to dev
    ‚Üì
GitHub Actions runs tests on dev
    ‚Üì PASS
Create PR: dev ‚Üí main
    ‚Üì
GitHub Actions runs tests on PR
    ‚Üì PASS
Merge PR to main
    ‚Üì
Render detects main branch update
    ‚Üì
Render builds and deploys to production
    ‚Üì
Production updated ‚úÖ
```

### Branch Protection Rules

**Main Branch Protection** (configured on GitHub):
- ‚úÖ Require pull request before merging
- ‚úÖ Require status checks to pass (e2e-tests, django-tests)
- ‚úÖ Require branches to be up to date before merging
- ‚úÖ Include administrators (even admins must follow rules)
- ‚ùå Direct push to main is BLOCKED
- ‚ùå Merge is BLOCKED if tests fail

**Dev Branch** (less strict):
- ‚úÖ Can push directly to dev for quick iterations
- ‚úÖ Tests run automatically on every push
- ‚úÖ Pull Request required for `dev ‚Üí main` (enforced by main branch protection)

### Commit Message Guidelines

Follow conventional commits format:

```
feat: add new feature
fix: fix bug in existing feature
test: add or update tests
docs: update documentation
refactor: refactor code without changing functionality
style: code style changes (formatting, etc.)
chore: maintenance tasks
hotfix: critical production bug fix
```

**Examples**:
- `feat: implement character blocking system`
- `fix: resolve login selector timeout in E2E tests`
- `test: add E2E tests for POKE system`
- `docs: update project status summary`
- `hotfix: fix critical database migration error`

### Before Every Commit

**MANDATORY CHECKLIST**:
- [ ] All Playwright tests pass locally (`pnpm test:e2e`)
- [ ] Database fixtures loaded (`pnpm load:fixtures`)
- [ ] New features have Playwright E2E tests
- [ ] Status documentation updated (if feature complete)
- [ ] No console errors in browser
- [ ] Code follows Django style guide (PEP 8)
- [ ] Committing to `dev` branch (NOT `main`)

### Additional Resources

Complete workflow documentation:
- **[Git Workflow Guide](../docs/GIT_WORKFLOW.md)** - Complete dev‚Üímain strategy with detailed examples
- **[CI/CD Strategy](../docs/CI_CD_STRATEGY.md)** - GitHub Actions + Render integration explained
- **[E2E Test Strategy](../docs/testing/E2E_TEST_STRATEGY.md)** - How to fix failing E2E tests
- **[E2E Test Results](../docs/testing/E2E_RESULTS_2025-12-28.md)** - Current test status and fixes needed

---

**Zasady organizacji dokumentacji:**

- Je≈õli powstaje kilka plik√≥w dokumentacji dotyczƒÖcych **tego samego feature**, umieszczamy je w **subfolderze nazwanym jak ten feature**.
- w **folderze feature** jeste≈õmy odpowiedzialni za utrzymywanie aktualnego `README.md` z nag≈Çowkami:
  - `Overview` z zarysem funkcjonalnosci,
  - `Project Status` z linkami do task√≥w oraz najaktualniejszym statusem od PMa.
  - `Index` z listƒÖ plikow w folderze i ich znaczeniem
- W folderach `docs/*/` **nie trzymamy wielu plik√≥w na ten sam temat luzem**, tylko pakujemy je w feature folders, czyli kazdy feature ma **w≈Çasny subkatalog**: `docs/*/<nazwa_zadania>/`

``` README.md

# <feature_name>

## Overview

## Project Status & Files Index

```



- Modyfikujac funkcjonalnosc strony oczekujemy ze istnieje adekwatna do niej doukumentacja i planujemy jej aktualizacje. Ponadto w komentarzach nag≈Ç√≥wkowych plik√≥w z kodem, umieszaczamy ≈õcie≈ºki do relewantnej dokumentacji. Uzupe≈Çniamy nasz codebase w brakujƒÖce ≈õcie≈ºki (wdra≈ºamy dopiero te ideƒô). Utrzymywanie ≈õcie≈ºek do adekwatnych docs pozwala nam 